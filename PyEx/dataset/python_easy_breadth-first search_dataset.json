{
    "100": {
        "title": "Same Tree",
        "difficulty": "Easy",
        "question": "Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\n**Example 1:**\n\n**Input:** p = \\[1,2,3\\], q = \\[1,2,3\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** p = \\[1,2\\], q = \\[1,null,2\\]\n**Output:** false\n\n**Example 3:**\n\n**Input:** p = \\[1,2,1\\], q = \\[1,1,2\\]\n**Output:** false\n\n**Constraints:**\n\n*   The number of nodes in both trees is in the range `[0, 100]`.\n*   `-104 <= Node.val <= 104`",
        "answer": "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_same_tree(p, q):\n    if p is None and q is None:\n        return True\n    if p is None or q is None:\n        return False\n    if p.val != q.val:\n        return False\n    return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)\n```\n\n"
    },
    "101": {
        "title": "Symmetric Tree",
        "difficulty": "Easy",
        "question": "Given the `root` of a binary tree, _check whether it is a mirror of itself_ (i.e., symmetric around its center).\n\n**Example 1:**\n\n**Input:** root = \\[1,2,2,3,4,4,3\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** root = \\[1,2,2,null,3,null,3\\]\n**Output:** false\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `-100 <= Node.val <= 100`\n\n**Follow up:** Could you solve it both recursively and iteratively?",
        "answer": "```python\ndef isSymmetric(root):\n    return checkSymmetry(root, root)\n\ndef checkSymmetry(node1, node2):\n    if not node1 and not node2:\n        return True\n    if not node1 or not node2:\n        return False\n    return (node1.val == node2.val) and checkSymmetry(node1.right, node2.left) and checkSymmetry(node1.left, node2.right)\n```\n"
    },
    "104": {
        "title": "Maximum Depth of Binary Tree",
        "difficulty": "Easy",
        "question": "Given the `root` of a binary tree, return _its maximum depth_.\n\nA binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 3\n\n**Example 2:**\n\n**Input:** root = \\[1,null,2\\]\n**Output:** 2\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-100 <= Node.val <= 100`",
        "answer": "```python\ndef maxDepth(root):\n    if root is None:\n        return 0\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))\n```\n"
    },
    "111": {
        "title": "Minimum Depth of Binary Tree",
        "difficulty": "Easy",
        "question": "Given a binary tree, find its minimum depth.\n\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n\n**Note:** A leaf is a node with no children.\n\n**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`",
        "answer": "```python\ndef minDepth(root):\n    if not root:\n        return 0\n    left = minDepth(root.left)\n    right = minDepth(root.right)\n    return (left == 0 or right == 0) and left + right + 1 or min(left, right) + 1\n```\n"
    },
    "112": {
        "title": "Path Sum",
        "difficulty": "Easy",
        "question": "Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`.\n\nA **leaf** is a node with no children.\n\n**Example 1:**\n\n**Input:** root = \\[5,4,8,11,null,13,4,7,2,null,null,null,1\\], targetSum = 22\n**Output:** true\n**Explanation:** The root-to-leaf path with the target sum is shown.\n\n**Example 2:**\n\n**Input:** root = \\[1,2,3\\], targetSum = 5\n**Output:** false\n**Explanation:** There two root-to-leaf paths in the tree:\n(1 --> 2): The sum is 3.\n(1 --> 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n\n**Example 3:**\n\n**Input:** root = \\[\\], targetSum = 0\n**Output:** false\n**Explanation:** Since the tree is empty, there are no root-to-leaf paths.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 5000]`.\n*   `-1000 <= Node.val <= 1000`\n*   `-1000 <= targetSum <= 1000`",
        "answer": "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef hasPathSum(root, targetSum):\n    if root is None:\n        return False\n    if root.left is None and root.right is None:\n        return targetSum - root.val == 0\n    return hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val)\n```\n"
    },
    "226": {
        "title": "Invert Binary Tree",
        "difficulty": "Easy",
        "question": "Given the `root` of a binary tree, invert the tree, and return _its root_.\n\n**Example 1:**\n\n**Input:** root = \\[4,2,7,1,3,6,9\\]\n**Output:** \\[4,7,2,9,6,3,1\\]\n\n**Example 2:**\n\n**Input:** root = \\[2,1,3\\]\n**Output:** \\[2,3,1\\]\n\n**Example 3:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`",
        "answer": "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef invert_tree(root):\n    if root is None:\n        return None\n    root.left, root.right = invert_tree(root.right), invert_tree(root.left)\n    return root\n```\n"
    },
    "404": {
        "title": "Sum of Left Leaves",
        "difficulty": "Easy",
        "question": "Given the `root` of a binary tree, return _the sum of all left leaves._\n\nA **leaf** is a node with no children. A **left leaf** is a leaf that is the left child of another node.\n\n**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 24\n**Explanation:** There are two left leaves in the binary tree, with values 9 and 15 respectively.\n\n**Example 2:**\n\n**Input:** root = \\[1\\]\n**Output:** 0\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `-1000 <= Node.val <= 1000`",
        "answer": "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef sum_of_left_leaves(root):\n    if not root:\n        return 0\n    left_sum = 0\n    if root.left and not root.left.left and not root.left.right:\n        left_sum += root.left.val\n    return left_sum + sum_of_left_leaves(root.left) + sum_of_left_leaves(root.right)\n```\n"
    },
    "463": {
        "title": "Island Perimeter",
        "difficulty": "Easy",
        "question": "You are given `row x col` `grid` representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water.\n\nGrid cells are connected **horizontally/vertically** (not diagonally). The `grid` is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\n\nThe island doesn't have \"lakes \", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,0,0\\],\\[1,1,1,0\\],\\[0,1,0,0\\],\\[1,1,0,0\\]\\]\n**Output:** 16\n**Explanation:** The perimeter is the 16 yellow stripes in the image above.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1\\]\\]\n**Output:** 4\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,0\\]\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `row == grid.length`\n*   `col == grid[i].length`\n*   `1 <= row, col <= 100`\n*   `grid[i][j]` is `0` or `1`.\n*   There is exactly one island in `grid`.",
        "answer": "```python\ndef islandPerimeter(grid):\n    perimeter = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[row])):\n            if grid[row][col] == 1:\n                perimeter += 4\n                if row > 0 and grid[row - 1][col] == 1:\n                    perimeter -= 2\n                if col > 0 and grid[row][col - 1] == 1:\n                    perimeter -= 2\n    return perimeter\n```\n"
    },
    "530": {
        "title": "Minimum Absolute Difference in BST",
        "difficulty": "Easy",
        "question": "Given the `root` of a Binary Search Tree (BST), return _the minimum absolute difference between the values of any two different nodes in the tree_.\n\n**Example 1:**\n\n**Input:** root = \\[4,2,6,1,3\\]\n**Output:** 1\n\n**Example 2:**\n\n**Input:** root = \\[1,0,48,null,null,12,49\\]\n**Output:** 1\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[2, 104]`.\n*   `0 <= Node.val <= 105`\n\n**Note:** This question is the same as 783: [https://leetcode.com/problems/minimum-distance-between-bst-nodes/](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)",
        "answer": "```python\nclass TreeNode:\n    def __init__(self, x: int):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def getMinimumDifference(self, root: TreeNode) -> int:\n        result = float('inf')\n        prev = None\n\n        def inorderTraversal(node):\n            nonlocal result, prev\n            if node is None:\n                return\n            inorderTraversal(node.left)\n            if prev is not None:\n                result = min(result, node.val - prev.val)\n            prev = node\n            inorderTraversal(node.right)\n\n        inorderTraversal(root)\n        return result\n```\n"
    },
    "617": {
        "title": "Merge Two Binary Trees",
        "difficulty": "Easy",
        "question": "You are given two binary trees `root1` and `root2`.\n\nImagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.\n\nReturn _the merged tree_.\n\n**Note:** The merging process must start from the root nodes of both trees.\n\n**Example 1:**\n\n**Input:** root1 = \\[1,3,2,5\\], root2 = \\[2,1,3,null,4,null,7\\]\n**Output:** \\[3,4,5,5,4,null,7\\]\n\n**Example 2:**\n\n**Input:** root1 = \\[1\\], root2 = \\[1,2\\]\n**Output:** \\[2,2\\]\n\n**Constraints:**\n\n*   The number of nodes in both trees is in the range `[0, 2000]`.\n*   `-104 <= Node.val <= 104`",
        "answer": "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef merge_trees(root1: TreeNode, root2: TreeNode) -> TreeNode:\n    if root1 is None: return root2\n    if root2 is None: return root1\n\n    root1.val += root2.val\n    root1.left = merge_trees(root1.left, root2.left)\n    root1.right = merge_trees(root1.right, root2.right)\n    return root1\n```\n"
    },
    "637": {
        "title": "Average of Levels in Binary Tree",
        "difficulty": "Easy",
        "question": "Given the `root` of a binary tree, return _the average value of the nodes on each level in the form of an array_. Answers within `10-5` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return \\[3, 14.5, 11\\].\n\n**Example 2:**\n\n**Input:** root = \\[3,9,20,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`",
        "answer": "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef averageOfLevels(root: TreeNode):\n    result = []\n    queue = [root]\n\n    while queue:\n        sum_ = 0\n        count = 0\n        temp = []\n        while queue:\n            node = queue.pop(0)\n            sum_ += node.val\n            count += 1\n            if node.left: temp.append(node.left)\n            if node.right: temp.append(node.right)\n        queue = temp\n        result.append(sum_ / count)\n\n    return result\n```\n"
    },
    "733": {
        "title": "Flood Fill",
        "difficulty": "Easy",
        "question": "An image is represented by an `m x n` integer grid `image` where `image[i][j]` represents the pixel value of the image.\n\nYou are also given three integers `sr`, `sc`, and `color`. You should perform a **flood fill** on the image starting from the pixel `image[sr][sc]`.\n\nTo perform a **flood fill**, consider the starting pixel, plus any pixels connected **4-directionally** to the starting pixel of the same color as the starting pixel, plus any pixels connected **4-directionally** to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with `color`.\n\nReturn _the modified image after performing the flood fill_.\n\n**Example 1:**\n\n**Input:** image = \\[\\[1,1,1\\],\\[1,1,0\\],\\[1,0,1\\]\\], sr = 1, sc = 1, color = 2\n**Output:** \\[\\[2,2,2\\],\\[2,2,0\\],\\[2,0,1\\]\\]\n**Explanation:** From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.\n\n**Example 2:**\n\n**Input:** image = \\[\\[0,0,0\\],\\[0,0,0\\]\\], sr = 0, sc = 0, color = 0\n**Output:** \\[\\[0,0,0\\],\\[0,0,0\\]\\]\n**Explanation:** The starting pixel is already colored 0, so no changes are made to the image.\n\n**Constraints:**\n\n*   `m == image.length`\n*   `n == image[i].length`\n*   `1 <= m, n <= 50`\n*   `0 <= image[i][j], color < 216`\n*   `0 <= sr < m`\n*   `0 <= sc < n`",
        "answer": "```python\ndef floodFill(image, sr, sc, newColor):\n    startColor = image[sr][sc]\n    def fill(sr, sc):\n        if not (0 <= sr < len(image)) or not (0 <= sc < len(image[0])) or image[sr][sc] != startColor or image[sr][sc] == newColor: \n            return\n        image[sr][sc] = newColor\n        fill(sr - 1, sc)\n        fill(sr + 1, sc)\n        fill(sr, sc - 1)\n        fill(sr, sc + 1)\n    \n    fill(sr, sc)\n    return image\n```\n\n"
    },
    "744": {
        "title": "Find Smallest Letter Greater Than Target",
        "difficulty": "Easy",
        "question": "You are given an array of characters `letters` that is sorted in **non-decreasing order**, and a character `target`. There are **at least two different** characters in `letters`.\n\nReturn _the smallest character in_ `letters` _that is lexicographically greater than_ `target`. If such a character does not exist, return the first character in `letters`.\n\n**Example 1:**\n\n**Input:** letters = \\[ \"c \", \"f \", \"j \"\\], target =  \"a \"\n**Output:**  \"c \"\n**Explanation:** The smallest character that is lexicographically greater than 'a' in letters is 'c'.\n\n**Example 2:**\n\n**Input:** letters = \\[ \"c \", \"f \", \"j \"\\], target =  \"c \"\n**Output:**  \"f \"\n**Explanation:** The smallest character that is lexicographically greater than 'c' in letters is 'f'.\n\n**Example 3:**\n\n**Input:** letters = \\[ \"x \", \"x \", \"y \", \"y \"\\], target =  \"z \"\n**Output:**  \"x \"\n**Explanation:** There are no characters in letters that is lexicographically greater than 'z' so we return letters\\[0\\].\n\n**Constraints:**\n\n*   `2 <= letters.length <= 104`\n*   `letters[i]` is a lowercase English letter.\n*   `letters` is sorted in **non-decreasing** order.\n*   `letters` contains at least two different characters.\n*   `target` is a lowercase English letter.",
        "answer": "```python\nimport heapq\nfrom collections import defaultdict\n\ndef networkDelayTime(times, n, k):\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    dist = {i: float('inf') for i in range(1, n + 1)}\n    dist[k] = 0\n\n    pq = [(0, k)]\n\n    while pq:\n        time, node = heapq.heappop(pq)\n\n        if time > dist[node]:\n            continue\n\n        for neighbour, neighbourTime in graph[node]:\n            candidate_dist = time + neighbourTime\n            if candidate_dist < dist[neighbour]:\n                dist[neighbour] = candidate_dist\n                heapq.heappush(pq, (candidate_dist, neighbour))\n\n    maxTime = max(dist.values())\n    return maxTime if maxTime < float('inf') else -1\n```\n"
    },
    "771": {
        "title": "Jewels and Stones",
        "difficulty": "Easy",
        "question": "You're given strings `jewels` representing the types of stones that are jewels, and `stones` representing the stones you have. Each character in `stones` is a type of stone you have. You want to know how many of the stones you have are also jewels.\n\nLetters are case sensitive, so `\"a \"` is considered a different type of stone from `\"A \"`.\n\n**Example 1:**\n\n**Input:** jewels = \"aA\", stones = \"aAAbbbb\"\n**Output:** 3\n\n**Example 2:**\n\n**Input:** jewels = \"z\", stones = \"ZZ\"\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= jewels.length, stones.length <= 50`\n*   `jewels` and `stones` consist of only English letters.\n*   All the characters of `jewels` are **unique**.",
        "answer": "```python\ndef num_jewels_in_stones(jewels: str, stones: str) -> int:\n    count = 0\n    for stone in stones:\n        if stone in jewels:\n            count += 1\n    return count\n```\n"
    },
    "884": {
        "title": "Uncommon Words from Two Sentences",
        "difficulty": "Easy",
        "question": "A **sentence** is a string of single-space separated words where each word consists only of lowercase letters.\n\nA word is **uncommon** if it appears exactly once in one of the sentences, and **does not appear** in the other sentence.\n\nGiven two **sentences** `s1` and `s2`, return _a list of all the **uncommon words**_. You may return the answer in **any order**.\n\n**Example 1:**\n\n**Input:** s1 = \"this apple is sweet\", s2 = \"this apple is sour\"\n**Output:** \\[\"sweet\",\"sour\"\\]\n\n**Example 2:**\n\n**Input:** s1 = \"apple apple\", s2 = \"banana\"\n**Output:** \\[\"banana\"\\]\n\n**Constraints:**\n\n*   `1 <= s1.length, s2.length <= 200`\n*   `s1` and `s2` consist of lowercase English letters and spaces.\n*   `s1` and `s2` do not have leading or trailing spaces.\n*   All the words in `s1` and `s2` are separated by a single space.",
        "answer": "```python\ndef k_similarity(s1, s2):\n    k = 0\n    a, b = list(s1), list(s2)\n    for i in range(len(a)):\n        if a[i] != b[i]:\n            for j in range(i + 1, len(b)):\n                if a[i] == b[j] and a[j] != b[j]:\n                    a[i], a[j] = a[j], a[i]\n                    k += 1\n                    break\n    return k\n```\n"
    },
    "922": {
        "title": "Sort Array By Parity II",
        "difficulty": "Easy",
        "question": "Given an array of integers `nums`, half of the integers in `nums` are **odd**, and the other half are **even**.\n\nSort the array so that whenever `nums[i]` is odd, `i` is **odd**, and whenever `nums[i]` is even, `i` is **even**.\n\nReturn _any answer array that satisfies this condition_.\n\n**Example 1:**\n\n**Input:** nums = \\[4,2,5,7\\]\n**Output:** \\[4,5,2,7\\]\n**Explanation:** \\[4,7,2,5\\], \\[2,5,4,7\\], \\[2,7,4,5\\] would also have been accepted.\n\n**Example 2:**\n\n**Input:** nums = \\[2,3\\]\n**Output:** \\[2,3\\]\n\n**Constraints:**\n\n*   `2 <= nums.length <= 2 * 104`\n*   `nums.length` is even.\n*   Half of the integers in `nums` are even.\n*   `0 <= nums[i] <= 1000`\n\n**Follow Up:** Could you solve it in-place?",
        "answer": "```python\nfrom collections import defaultdict\n\n\ndef possible_bipartition(n, dislikes):\n    def dfs(person, group):\n        if person in groups:\n            return groups[person] == group\n        groups[person] = group\n        for other in dislike_list[person]:\n            if not dfs(other, -group):\n                return False\n        return True\n\n    groups = {}\n    dislike_list = defaultdict(list)\n    for p1, p2 in dislikes:\n        dislike_list[p1].append(p2)\n        dislike_list[p2].append(p1)\n\n    for person in range(1, n + 1):\n        if person not in groups and not dfs(person, 1):\n            return False\n\n    return True\n```\n\n"
    },
    "999": {
        "title": "Available Captures for Rook",
        "difficulty": "Easy",
        "question": "On an `8 x 8` chessboard, there is **exactly one** white rook `'R'` and some number of white bishops `'B'`, black pawns `'p'`, and empty squares `'.'`.\n\nWhen the rook moves, it chooses one of four cardinal directions (north, east, south, or west), then moves in that direction until it chooses to stop, reaches the edge of the board, captures a black pawn, or is blocked by a white bishop. A rook is considered **attacking** a pawn if the rook can capture the pawn on the rook's turn. The **number of available captures** for the white rook is the number of pawns that the rook is **attacking**.\n\nReturn _the **number of available captures** for the white rook_.\n\n**Example 1:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"R \", \". \", \". \", \". \", \"p \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\]\\]\n**Output:** 3\n**Explanation:** In this example, the rook is attacking all the pawns.\n\n**Example 2:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"p \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"B \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"B \", \"R \", \"B \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"B \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"p \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\]\\]\n**Output:** 0\n**Explanation:** The bishops are blocking the rook from attacking any of the pawns.\n\n**Example 3:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \"p \", \"p \", \". \", \"R \", \". \", \"p \", \"B \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"B \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\]\\]\n**Output:** 3\n**Explanation:** The rook is attacking the pawns at positions b5, d6, and f5.\n\n**Constraints:**\n\n*   `board.length == 8`\n*   `board[i].length == 8`\n*   `board[i][j]` is either `'R'`, `'.'`, `'B'`, or `'p'`\n*   There is exactly one cell with `board[i][j] == 'R'`",
        "answer": "```python\ndef regionsBySlashes(grid):\n    n = len(grid)\n    graph = [[0] * (n * 3) for _ in range(n * 3)]\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == '/':\n                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1\n            if grid[i][j] == '\\\\':\n                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1\n\n    regions = 0\n    for i in range(n * 3):\n        for j in range(n * 3):\n            if not graph[i][j]:\n                regions += 1\n                dfs(graph, i, j)\n\n    return regions\n\ndef dfs(graph, i, j):\n    n = len(graph)\n    if i < 0 or j < 0 or i >= n or j >= n or graph[i][j]:\n        return\n\n    graph[i][j] = 1\n    dfs(graph, i - 1, j)\n    dfs(graph, i + 1, j)\n    dfs(graph, i, j - 1)\n    dfs(graph, i, j + 1)\n```\n"
    },
    "1005": {
        "title": "Maximize Sum Of Array After K Negations",
        "difficulty": "Easy",
        "question": "Given an integer array `nums` and an integer `k`, modify the array in the following way:\n\n*   choose an index `i` and replace `nums[i]` with `-nums[i]`.\n\nYou should apply this process exactly `k` times. You may choose the same index `i` multiple times.\n\nReturn _the largest possible sum of the array after modifying it in this way_.\n\n**Example 1:**\n\n**Input:** nums = \\[4,2,3\\], k = 1\n**Output:** 5\n**Explanation:** Choose index 1 and nums becomes \\[4,-2,3\\].\n\n**Example 2:**\n\n**Input:** nums = \\[3,-1,0,2\\], k = 3\n**Output:** 6\n**Explanation:** Choose indices (1, 2, 2) and nums becomes \\[3,1,0,2\\].\n\n**Example 3:**\n\n**Input:** nums = \\[2,-3,-1,5,-4\\], k = 2\n**Output:** 13\n**Explanation:** Choose indices (1, 4) and nums becomes \\[2,3,-1,5,4\\].\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-100 <= nums[i] <= 100`\n*   `1 <= k <= 104`",
        "answer": "```python\ndef is_univalued(root, val=None):\n    if not root:\n        return True\n    if val is None:\n        val = root.val\n    return root.val == val and is_univalued(root.left, val) and is_univalued(root.right, val)\n```\n"
    },
    "1099": {
        "title": "Two Sum Less Than K",
        "difficulty": "Easy",
        "question": "Given an array `nums` of integers and integer `k`, return the maximum `sum` such that there exists `i < j` with `nums[i] + nums[j] = sum` and `sum < k`. If no `i`, `j` exist satisfying this equation, return `-1`.\n\n**Example 1:**\n\n**Input:** nums = \\[34,23,1,24,75,33,54,8\\], k = 60\n**Output:** 58\n**Explanation:** We can use 34 and 24 to sum 58 which is less than 60.\n\n**Example 2:**\n\n**Input:** nums = \\[10,20,30\\], k = 15\n**Output:** -1\n**Explanation:** In this case it is not possible to get a pair sum less that 15.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 1000`\n*   `1 <= k <= 2000`",
        "answer": "```python\ndef max_sum_under_k(nums, k):\n    max_sum = -1\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            _sum = nums[i] + nums[j]\n            if _sum < k and _sum > max_sum:\n                max_sum = _sum\n    return max_sum\n```\n"
    },
    "1243": {
        "title": "Array Transformation",
        "difficulty": "Easy",
        "question": "Given an initial array `arr`, every day you produce a new array using the array of the previous day.\n\nOn the `i`\\-th day, you do the following operations on the array of day `i-1` to produce the array of day `i`:\n\n1.  If an element is smaller than both its left neighbor and its right neighbor, then this element is incremented.\n2.  If an element is bigger than both its left neighbor and its right neighbor, then this element is decremented.\n3.  The first and last elements never change.\n\nAfter some days, the array does not change. Return that final array.\n\n**Example 1:**\n\n**Input:** arr = \\[6,2,3,4\\]\n**Output:** \\[6,3,3,4\\]\n**Explanation:** \nOn the first day, the array is changed from \\[6,2,3,4\\] to \\[6,3,3,4\\].\nNo more operations can be done to this array.\n\n**Example 2:**\n\n**Input:** arr = \\[1,6,3,4,3,5\\]\n**Output:** \\[1,4,4,4,4,5\\]\n**Explanation:** \nOn the first day, the array is changed from \\[1,6,3,4,3,5\\] to \\[1,5,4,3,4,5\\].\nOn the second day, the array is changed from \\[1,5,4,3,4,5\\] to \\[1,4,4,4,4,5\\].\nNo more operations can be done to this array.\n\n**Constraints:**\n\n*   `3 <= arr.length <= 100`\n*   `1 <= arr[i] <= 100`",
        "answer": "```python\ndef sumEvenGrandparent(root, parent=None, grandparent=None):\n    if not root:\n        return 0\n    sum = 0\n    if grandparent and grandparent.val % 2 == 0:\n        sum += root.val\n    sum += sumEvenGrandparent(root.left, root, parent) + sumEvenGrandparent(root.right, root, parent)\n    return sum\n```\n"
    },
    "1271": {
        "title": "Hexspeak",
        "difficulty": "Easy",
        "question": "A decimal number can be converted to its **Hexspeak representation** by first converting it to an uppercase hexadecimal string, then replacing all occurrences of the digit `'0'` with the letter `'O'`, and the digit `'1'` with the letter `'I'`. Such a representation is valid if and only if it consists only of the letters in the set `{'A', 'B', 'C', 'D', 'E', 'F', 'I', 'O'}`.\n\nGiven a string `num` representing a decimal integer `n`, _return the **Hexspeak representation** of_ `n` _if it is valid, otherwise return_ `\"ERROR \"`.\n\n**Example 1:**\n\n**Input:** num =  \"257 \"\n**Output:**  \"IOI \"\n**Explanation:** 257 is 101 in hexadecimal.\n\n**Example 2:**\n\n**Input:** num =  \"3 \"\n**Output:**  \"ERROR \"\n\n**Constraints:**\n\n*   `1 <= num.length <= 12`\n*   `num` does not contain leading zeros.\n*   num represents an integer in the range `[1, 1012]`.",
        "answer": "```python\ndef to_hexspeak(num: str) -> str:\n    n = int(num)\n    hex_str = []\n    while n:\n        rem = n % 16\n        if rem == 1: hex_str.insert(0, 'I')\n        elif rem == 0: hex_str.insert(0, 'O')\n        elif rem > 9: hex_str.insert(0, chr(rem - 10 + ord('A')))\n        else: return 'ERROR'\n        n //= 16\n    return ''.join(hex_str)\n```\n"
    },
    "1275": {
        "title": "Find Winner on a Tic Tac Toe Game",
        "difficulty": "Easy",
        "question": "**Tic-tac-toe** is played by two players `A` and `B` on a `3 x 3` grid. The rules of Tic-Tac-Toe are:\n\n*   Players take turns placing characters into empty squares `' '`.\n*   The first player `A` always places `'X'` characters, while the second player `B` always places `'O'` characters.\n*   `'X'` and `'O'` characters are always placed into empty squares, never on filled ones.\n*   The game ends when there are **three** of the same (non-empty) character filling any row, column, or diagonal.\n*   The game also ends if all squares are non-empty.\n*   No more moves can be played if the game is over.\n\nGiven a 2D integer array `moves` where `moves[i] = [rowi, coli]` indicates that the `ith` move will be played on `grid[rowi][coli]`. return _the winner of the game if it exists_ (`A` or `B`). In case the game ends in a draw return `\"Draw \"`. If there are still movements to play return `\"Pending \"`.\n\nYou can assume that `moves` is valid (i.e., it follows the rules of **Tic-Tac-Toe**), the grid is initially empty, and `A` will play first.\n\n**Example 1:**\n\n**Input:** moves = \\[\\[0,0\\],\\[2,0\\],\\[1,1\\],\\[2,1\\],\\[2,2\\]\\]\n**Output:**  \"A \"\n**Explanation:** A wins, they always play first.\n\n**Example 2:**\n\n**Input:** moves = \\[\\[0,0\\],\\[1,1\\],\\[0,1\\],\\[0,2\\],\\[1,0\\],\\[2,0\\]\\]\n**Output:**  \"B \"\n**Explanation:** B wins.\n\n**Example 3:**\n\n**Input:** moves = \\[\\[0,0\\],\\[1,1\\],\\[2,0\\],\\[1,0\\],\\[1,2\\],\\[2,1\\],\\[0,1\\],\\[0,2\\],\\[2,2\\]\\]\n**Output:**  \"Draw \"\n**Explanation:** The game ends in a draw since there are no moves to make.\n\n**Constraints:**\n\n*   `1 <= moves.length <= 9`\n*   `moves[i].length == 2`\n*   `0 <= rowi, coli <= 2`\n*   There are no repeated elements on `moves`.\n*   `moves` follow the rules of tic tac toe.",
        "answer": "```python\ndef validateBinaryTreeNodes(n, leftChild, rightChild):\n    parent = [-1] * n\n    for i in range(n):\n        if leftChild[i] != -1:\n            if parent[leftChild[i]] != -1:\n                return False\n            parent[leftChild[i]] = i\n        if rightChild[i] != -1:\n            if parent[rightChild[i]] != -1:\n                return False\n            parent[rightChild[i]] = i\n    \n    root = -1\n    for i in range(n):\n        if parent[i] == -1:\n            if root != -1:\n                return False\n            root = i\n\n    return root != -1\n```\n"
    },
    "1309": {
        "title": "Decrypt String from Alphabet to Integer Mapping",
        "difficulty": "Easy",
        "question": "You are given a string `s` formed by digits and `'#'`. We want to map `s` to English lowercase characters as follows:\n\n*   Characters (`'a'` to `'i'`) are represented by (`'1'` to `'9'`) respectively.\n*   Characters (`'j'` to `'z'`) are represented by (`'10#'` to `'26#'`) respectively.\n\nReturn _the string formed after mapping_.\n\nThe test cases are generated so that a unique mapping will always exist.\n\n**Example 1:**\n\n**Input:** s =  \"10#11#12 \"\n**Output:**  \"jkab \"\n**Explanation:**  \"j \" ->  \"10# \" ,  \"k \" ->  \"11# \" ,  \"a \" ->  \"1 \" ,  \"b \" ->  \"2 \".\n\n**Example 2:**\n\n**Input:** s =  \"1326# \"\n**Output:**  \"acz \"\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of digits and the `'#'` letter.\n*   `s` will be a valid string such that mapping is always possible.",
        "answer": "```python\nfrom collections import defaultdict, deque\n\ndef sortItems(n, m, group, beforeItems):\n    def topological_sort(outdegree, edges):\n        res = []\n        q = deque([i for i in range(len(outdegree)) if outdegree[i] == 0])\n        while q:\n            u = q.pop()\n            res.append(u)\n            for v in edges[u]:\n                outdegree[v] -= 1\n                if outdegree[v] == 0:\n                    q.append(v)\n        return res\n\n    # Calculate outdegrees and dependencies for groups and items\n    group_outdegree = [0] * m\n    group_edges = defaultdict(list)\n\n    item_outdegree = [0] * n\n    item_edges = defaultdict(list)\n\n    for i in range(n):\n        for dep in beforeItems[i]:\n            a, b = group[i], group[dep]\n            if a != -1 and a != b and not (group_edges[b] and group_edges[b][-1] == a):\n                group_edges[b].append(a)\n                group_outdegree[a] += 1\n            if a != b:\n                item_edges[dep].append(i)\n                item_outdegree[i] += 1\n\n    group_order = topological_sort(group_outdegree, group_edges)\n    if len(group_order) < m:\n        return []\n\n    item_order = topological_sort(item_outdegree, item_edges)\n    if len(item_order) < n:\n        return []\n\n    # Combine orders\n    res = [0] * n\n    idx = 0\n    for gi in group_order:\n        for item_idx in item_order:\n            if group[item_idx] == gi:\n                res[idx] = item_idx\n                idx += 1\n\n    return res\n```\n\n"
    },
    "1380": {
        "title": "Lucky Numbers in a Matrix",
        "difficulty": "Easy",
        "question": "Given an `m x n` matrix of **distinct** numbers, return _all **lucky numbers** in the matrix in **any** order_.\n\nA **lucky number** is an element of the matrix such that it is the minimum element in its row and maximum in its column.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[3,7,8\\],\\[9,11,13\\],\\[15,16,17\\]\\]\n**Output:** \\[15\\]\n**Explanation:** 15 is the only lucky number since it is the minimum in its row and the maximum in its column.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[1,10,4,2\\],\\[9,3,8,7\\],\\[15,16,17,12\\]\\]\n**Output:** \\[12\\]\n**Explanation:** 12 is the only lucky number since it is the minimum in its row and the maximum in its column.\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[7,8\\],\\[1,2\\]\\]\n**Output:** \\[7\\]\n**Explanation:** 7 is the only lucky number since it is the minimum in its row and the maximum in its column.\n\n**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= n, m <= 50`\n*   `1 <= matrix[i][j] <= 105`.\n*   All elements in the matrix are distinct.",
        "answer": "```python\ndx = [-1, 1, 0, 0]\ndy = [0, 0, -1, 1]\n\ndef dfs(grid, x, y):\n    n, m = len(grid), len(grid[0])\n    grid[x][y] = 1\n    for i in range(4):\n        nx, ny = x + dx[i], y + dy[i]\n        if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0:\n            dfs(grid, nx, ny)\n\ndef closedIsland(grid):\n    n, m = len(grid), len(grid[0])\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or i == n - 1 or j == 0 or j == m - 1:\n                if grid[i][j] == 0:\n                    dfs(grid, i, j)\n    res = 0\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            if grid[i][j] == 0:\n                dfs(grid, i, j)\n                res += 1\n    return res\n```\n\n"
    },
    "1431": {
        "title": "Kids With the Greatest Number of Candies",
        "difficulty": "Easy",
        "question": "There are `n` kids with candies. You are given an integer array `candies`, where each `candies[i]` represents the number of candies the `ith` kid has, and an integer `extraCandies`, denoting the number of extra candies that you have.\n\nReturn _a boolean array_ `result` _of length_ `n`_, where_ `result[i]` _is_ `true` _if, after giving the_ `ith` _kid all the_ `extraCandies`_, they will have the **greatest** number of candies among all the kids__, or_ `false` _otherwise_.\n\nNote that **multiple** kids can have the **greatest** number of candies.\n\n**Example 1:**\n\n**Input:** candies = \\[2,3,5,1,3\\], extraCandies = 3\n**Output:** \\[true,true,true,false,true\\] \n**Explanation:** If you give all extraCandies to:\n- Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids.\n- Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n- Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids.\n- Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids.\n- Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n\n**Example 2:**\n\n**Input:** candies = \\[4,2,1,1,2\\], extraCandies = 1\n**Output:** \\[true,false,false,false,false\\] \n**Explanation:** There is only 1 extra candy.\nKid 1 will always have the greatest number of candies, even if a different kid is given the extra candy.\n\n**Example 3:**\n\n**Input:** candies = \\[12,1,12\\], extraCandies = 10\n**Output:** \\[true,false,true\\]\n\n**Constraints:**\n\n*   `n == candies.length`\n*   `2 <= n <= 100`\n*   `1 <= candies[i] <= 100`\n*   `1 <= extraCandies <= 50`",
        "answer": "```python\nfrom collections import defaultdict\n\ndef find_ancestors(node, adj_list, visited, ans):\n    if visited[node]:\n        return\n    visited[node] = True\n    for ancestor in adj_list[node]:\n        ans.append(ancestor)\n        find_ancestors(ancestor, adj_list, visited, ans)\n\ndef find_ancestors_in_dag(n, edges):\n    adj_list = defaultdict(list)\n    for edge in edges:\n        adj_list[edge[1]].append(edge[0])\n    ans = []\n    for i in range(n):\n        visited = [False] * n\n        ancestors = []\n        find_ancestors(i, adj_list, visited, ancestors)\n        ans.append(sorted(ancestors))\n    return ans\n```\n\n"
    },
    "1436": {
        "title": "Destination City",
        "difficulty": "Easy",
        "question": "You are given the array `paths`, where `paths[i] = [cityAi, cityBi]` means there exists a direct path going from `cityAi` to `cityBi`. _Return the destination city, that is, the city without any path outgoing to another city._\n\nIt is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.\n\n**Example 1:**\n\n**Input:** paths = \\[\\[ \"London \", \"New York \"\\],\\[ \"New York \", \"Lima \"\\],\\[ \"Lima \", \"Sao Paulo \"\\]\\]\n**Output:**  \"Sao Paulo \" \n**Explanation:** Starting at  \"London \" city you will reach  \"Sao Paulo \" city which is the destination city. Your trip consist of:  \"London \" ->  \"New York \" ->  \"Lima \" ->  \"Sao Paulo \".\n\n**Example 2:**\n\n**Input:** paths = \\[\\[ \"B \", \"C \"\\],\\[ \"D \", \"B \"\\],\\[ \"C \", \"A \"\\]\\]\n**Output:**  \"A \"\n**Explanation:** All possible trips are: \n \"D \" ->  \"B \" ->  \"C \" ->  \"A \". \n \"B \" ->  \"C \" ->  \"A \". \n \"C \" ->  \"A \". \n \"A \". \nClearly the destination city is  \"A \".\n\n**Example 3:**\n\n**Input:** paths = \\[\\[ \"A \", \"Z \"\\]\\]\n**Output:**  \"Z \"\n\n**Constraints:**\n\n*   `1 <= paths.length <= 100`\n*   `paths[i].length == 2`\n*   `1 <= cityAi.length, cityBi.length <= 10`\n*   `cityAi != cityBi`\n*   All strings consist of lowercase and uppercase English letters and the space character.",
        "answer": "```python\nfrom collections import deque\nfrom collections import defaultdict\n\ndef watched_videos_by_friends(watched_videos, friends, id, level):\n    visited = set()\n    q = deque([(id, 0)])\n    video_freq = defaultdict(int)\n\n    while q:\n        current_id, current_level = q.popleft()\n\n        if current_level == level:\n            for video in watched_videos[current_id]:\n                video_freq[video] += 1\n        elif current_level < level:\n            for friend_id in friends[current_id]:\n                if friend_id not in visited:\n                    visited.add(friend_id)\n                    q.append((friend_id, current_level + 1))\n\n    result = sorted(video_freq.keys(), key=lambda x: (video_freq[x], x))\n\n    return result\n```\n"
    },
    "1507": {
        "title": "Reformat Date",
        "difficulty": "Easy",
        "question": "Given a `date` string in the form `Day Month Year`, where:\n\n*   `Day` is in the set `{ \"1st \", \"2nd \", \"3rd \", \"4th \", ..., \"30th \", \"31st \"}`.\n*   `Month` is in the set `{ \"Jan \", \"Feb \", \"Mar \", \"Apr \", \"May \", \"Jun \", \"Jul \", \"Aug \", \"Sep \", \"Oct \", \"Nov \", \"Dec \"}`.\n*   `Year` is in the range `[1900, 2100]`.\n\nConvert the date string to the format `YYYY-MM-DD`, where:\n\n*   `YYYY` denotes the 4 digit year.\n*   `MM` denotes the 2 digit month.\n*   `DD` denotes the 2 digit day.\n\n**Example 1:**\n\n**Input:** date =  \"20th Oct 2052 \"\n**Output:**  \"2052-10-20 \"\n\n**Example 2:**\n\n**Input:** date =  \"6th Jun 1933 \"\n**Output:**  \"1933-06-06 \"\n\n**Example 3:**\n\n**Input:** date =  \"26th May 1960 \"\n**Output:**  \"1960-05-26 \"\n\n**Constraints:**\n\n*   The given dates are guaranteed to be valid, so no error handling is necessary.",
        "answer": "```python\ndef hasValidPath(grid):\n    m, n = len(grid), len(grid[0])\n    visited = [[False for _ in range(n)] for _ in range(m)]\n\n    return dfs(grid, 0, 0, m, n, visited)\n\ndef dfs(grid, x, y, m, n, visited):\n    if x < 0 or y < 0 or x >= m or y >= n or visited[x][y]:\n        return False\n    if x == m - 1 and y == n - 1:\n        return True\n    \n    visited[x][y] = True\n\n    next_x = [-1, 0, 1, 0]\n    next_y = [0, 1, 0, -1]\n\n    for i in range(4):\n        dx = x + next_x[i]\n        dy = y + next_y[i]\n\n        if dfs(grid, dx, dy, m, n, visited):\n            return True\n\n    return False\n```\n"
    },
    "1544": {
        "title": "Make The String Great",
        "difficulty": "Easy",
        "question": "Given a string `s` of lower and upper case English letters.\n\nA good string is a string which doesn't have **two adjacent characters** `s[i]` and `s[i + 1]` where:\n\n*   `0 <= i <= s.length - 2`\n*   `s[i]` is a lower-case letter and `s[i + 1]` is the same letter but in upper-case or **vice-versa**.\n\nTo make the string good, you can choose **two adjacent** characters that make the string bad and remove them. You can keep doing this until the string becomes good.\n\nReturn _the string_ after making it good. The answer is guaranteed to be unique under the given constraints.\n\n**Notice** that an empty string is also good.\n\n**Example 1:**\n\n**Input:** s =  \"leEeetcode \"\n**Output:**  \"leetcode \"\n**Explanation:** In the first step, either you choose i = 1 or i = 2, both will result  \"leEeetcode \" to be reduced to  \"leetcode \".\n\n**Example 2:**\n\n**Input:** s =  \"abBAcC \"\n**Output:**  \" \"\n**Explanation:** We have many possible scenarios, and all lead to the same answer. For example:\n \"abBAcC \" -->  \"aAcC \" -->  \"cC \" -->  \" \"\n \"abBAcC \" -->  \"abBA \" -->  \"aA \" -->  \" \"\n\n**Example 3:**\n\n**Input:** s =  \"s \"\n**Output:**  \"s \"\n\n**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` contains only lower and upper case English letters.",
        "answer": "```python\ndef goodNodes(root, maxVal=float('-inf')):\n    if not root:\n        return 0\n    result = 0\n    if root.val >= maxVal:\n        result = 1\n        maxVal = root.val\n    return result + goodNodes(root.left, maxVal) + goodNodes(root.right, maxVal)\n```\n"
    },
    "1576": {
        "title": "Replace All ?'s to Avoid Consecutive Repeating Characters",
        "difficulty": "Easy",
        "question": "Given a string `s` containing only lowercase English letters and the `'?'` character, convert **all** the `'?'` characters into lowercase letters such that the final string does not contain any **consecutive repeating** characters. You **cannot** modify the non `'?'` characters.\n\nIt is **guaranteed** that there are no consecutive repeating characters in the given string **except** for `'?'`.\n\nReturn _the final string after all the conversions (possibly zero) have been made_. If there is more than one solution, return **any of them**. It can be shown that an answer is always possible with the given constraints.\n\n**Example 1:**\n\n**Input:** s =  \"?zs \"\n**Output:**  \"azs \"\n**Explanation:** There are 25 solutions for this problem. From  \"azs \" to  \"yzs \", all are valid. Only  \"z \" is an invalid modification as the string will consist of consecutive repeating characters in  \"zzs \".\n\n**Example 2:**\n\n**Input:** s =  \"ubv?w \"\n**Output:**  \"ubvaw \"\n**Explanation:** There are 24 solutions for this problem. Only  \"v \" and  \"w \" are invalid modifications as the strings will consist of consecutive repeating characters in  \"ubvvw \" and  \"ubvww \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consist of lowercase English letters and `'?'`.",
        "answer": "```python\nfrom collections import defaultdict\n\ndef dfs(node, parent, graph, count):\n    if node != 0 and parent == 0:\n        count[0] += 1\n\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, graph, count)\n\ndef minReorder(n, connections):\n    graph = defaultdict(list)\n    for a, b in connections:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    count = [0]\n    dfs(0, -1, graph, count)\n    return count[0]\n```\n"
    },
    "1876": {
        "title": "Substrings of Size Three with Distinct Characters",
        "difficulty": "Easy",
        "question": "A string is **good** if there are no repeated characters.\n\nGiven a string `s`\u200b\u200b\u200b\u200b\u200b, return _the number of **good substrings** of length **three** in_ `s`\u200b\u200b\u200b\u200b\u200b\u200b.\n\nNote that if there are multiple occurrences of the same substring, every occurrence should be counted.\n\nA **substring** is a contiguous sequence of characters in a string.\n\n**Example 1:**\n\n**Input:** s =  \"xyzzaz \"\n**Output:** 1\n**Explanation:** There are 4 substrings of size 3:  \"xyz \",  \"yzz \",  \"zza \", and  \"zaz \". \nThe only good substring of length 3 is  \"xyz \".\n\n**Example 2:**\n\n**Input:** s =  \"aababcabc \"\n**Output:** 4\n**Explanation:** There are 7 substrings of size 3:  \"aab \",  \"aba \",  \"bab \",  \"abc \",  \"bca \",  \"cab \", and  \"abc \".\nThe good substrings are  \"abc \",  \"bca \",  \"cab \", and  \"abc \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s`\u200b\u200b\u200b\u200b\u200b\u200b consists of lowercase English letters.",
        "answer": "```python\nfrom collections import deque\n\ndef highest_island(is_water):\n    m, n = len(is_water), len(is_water[0])\n    height = [[-1] * n for _ in range(m)]\n    q = deque()\n\n    for i in range(m):\n        for j in range(n):\n            if is_water[i][j] == 1:\n                height[i][j] = 0\n                q.append((i, j))\n\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n\n    while q:\n        x, y = q.popleft()\n\n        for i in range(4):\n            newX = x + dx[i]\n            newY = y + dy[i]\n\n            if 0 <= newX < m and 0 <= newY < n and height[newX][newY] == -1:\n                height[newX][newY] = height[x][y] + 1\n                q.append((newX, newY))\n\n    return height\n```\n"
    },
    "2103": {
        "title": "Rings and Rods",
        "difficulty": "Easy",
        "question": "There are `n` rings and each ring is either red, green, or blue. The rings are distributed **across ten rods** labeled from `0` to `9`.\n\nYou are given a string `rings` of length `2n` that describes the `n` rings that are placed onto the rods. Every two characters in `rings` forms a **color-position pair** that is used to describe each ring where:\n\n*   The **first** character of the `ith` pair denotes the `ith` ring's **color** (`'R'`, `'G'`, `'B'`).\n*   The **second** character of the `ith` pair denotes the **rod** that the `ith` ring is placed on (`'0'` to `'9'`).\n\nFor example, `\"R3G2B1 \"` describes `n == 3` rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1.\n\nReturn _the number of rods that have **all three colors** of rings on them._\n\n**Example 1:**\n\n**Input:** rings =  \"B0B6G0R6R0R6G9 \"\n**Output:** 1\n**Explanation:** \n- The rod labeled 0 holds 3 rings with all colors: red, green, and blue.\n- The rod labeled 6 holds 3 rings, but it only has red and blue.\n- The rod labeled 9 holds only a green ring.\nThus, the number of rods with all three colors is 1.\n\n**Example 2:**\n\n**Input:** rings =  \"B0R0G0R9R0B0G0 \"\n**Output:** 1\n**Explanation:** \n- The rod labeled 0 holds 6 rings with all colors: red, green, and blue.\n- The rod labeled 9 holds only a red ring.\nThus, the number of rods with all three colors is 1.\n\n**Example 3:**\n\n**Input:** rings =  \"G4 \"\n**Output:** 0\n**Explanation:** \nOnly one ring is given. Thus, no rods have all three colors.\n\n**Constraints:**\n\n*   `rings.length == 2 * n`\n*   `1 <= n <= 100`\n*   `rings[i]` where `i` is **even** is either `'R'`, `'G'`, or `'B'` (**0-indexed**).\n*   `rings[i]` where `i` is **odd** is a digit from `'0'` to `'9'` (**0-indexed**).",
        "answer": "```python\ndef findFarmland(land):\n    m, n = len(land), len(land[0])\n    res = []\n    \n    for i in range(m):\n        for j in range(n):\n            if land[i][j] == 1:\n                r, c = i, j\n                while r < m and land[r][j] == 1: r += 1\n                while c < n and land[i][c] == 1: c += 1\n                for x in range(i, r):\n                    for y in range(j,c):\n                        land[x][y] = 0\n                res.append([i, j, r - 1, c - 1])\n\n    return res\n```\n\n"
    }
}